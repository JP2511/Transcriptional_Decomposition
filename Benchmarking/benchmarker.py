import sys
sys.path[0] += "/../src/TranscriptDecomPy/"

import utils
import inla_TD
import distributions_TD as dist_TD

import torch
import functools

import dask.array as da
import dask.dataframe as dd

from torch.distributions.multivariate_normal import MultivariateNormal

device = utils.device

###############################################################################

def neg_p_theta_given_y(curr_theta: torch.tensor,
                        n_feat: int,
                        obs: da.array,
                        theta_intercept: torch.tensor) -> float:
    """Creates the function that calculates the -log p(theta | y) for the
    generated data.

    Args:
        curr_theta (int): parameters used in the calculation of the 
            probability.

    Returns:
        float: - log p(theta | y)
    """

    theta_intercept = theta_intercept
    theta_y, theta_PD, theta_PI = curr_theta
    new_Q = dist_TD.build_gmrf_Q(n_feat, theta_intercept, theta_PD,
                                    theta_PI)

    init_v = utils.gen_tensor(0, n_feat * 2 + 1)
    link_f = lambda x: torch.exp(dist_TD.subsetting_latent_var(x))
    data_likelihood = functools.partial(dist_TD.log_likelihood_neg_binom,
                                        obs=obs, link_f=link_f,
                                        theta_y=theta_y)
    
    mode_x, ga_L = inla_TD.p_x_given_y_theta(data_likelihood, new_Q, init_v)

    gmrf_prior = inla_TD.create_gmrf_density_func(new_Q)
    theta_I = torch.eye(3, dtype=torch.float64, device=device)
    theta_dist = MultivariateNormal(utils.gen_tensor(0, 3), theta_I).log_prob
    p_theta_y = inla_TD.approx_marg_post_of_theta(data_likelihood,
                                                    theta=curr_theta,
                                                    gmrf_likelihood=gmrf_prior,
                                                    theta_dist=theta_dist,
                                                    gaus_approx_mean=mode_x,
                                                    gaus_approx_L=ga_L)
        
    return (mode_x, ga_L, -p_theta_y)


def functional_bound(theta: torch.tensor) -> torch.tensor:
    """Function that converts the thetas generated by the minimization
    function into thetas that fall into the valid parameter space domain in
    which they exists. Here, I use the sigmoid function to restrict theta_y
    into the [0, 1] interval, and use the exponential function to convert
    the rest of thetas into the [0, +inf) space.

    Args:
        theta (torch.tensor): parameters of the model.

    Returns:
        torch.tensor: bounded parameters.
    """

    theta_y, *gmrf_theta = theta
    theta_y = torch.sigmoid(theta_y)

    gmrf_theta = torch.exp(torch.hstack(gmrf_theta))
    return torch.hstack((theta_y, gmrf_theta))


def get_credible_int(obs: da.array, theta_intercept: torch.tensor):

    n_feat = obs.shape[-1]

    adj_neg_p_theta_given_y = functools.partial(neg_p_theta_given_y,
                                                n_feat=n_feat,
                                                obs=obs,
                                                theta_intercept=theta_intercept)

    init_guess = torch.hstack((utils.gen_tensor(0.5), utils.gen_tensor(1, 2)))
    points = inla_TD.explore_p_theta_given_y(adj_neg_p_theta_given_y,
                                                functional_bound,
                                                init_guess,
                                                0.5,
                                                2.5)
    
    m, conf = inla_TD.obtain_cred_int_x(points, init_guess.shape[-1], 
                                        n_feat, True, 0.05)

    h = torch.vstack((m, conf))


##############################################################################

if __name__ == '__main__':
    da.register_chunk_type(utils.DaskTensor)

    ds = dd.read_csv("datasets/data_4000_5.csv", blocksize=3e9, header=None)
    ds_array = ds.to_dask_array()
    ds_tensor = da.map_blocks(lambda x: utils.DaskTensor(utils.gen_tensor(x)),
                                ds_array)

    get_credible_int(ds_tensor, utils.gen_tensor(0.6))